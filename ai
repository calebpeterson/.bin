#!/usr/bin/env bun

import { isEmpty, isString, trim } from "lodash";
import { v4 as uuid4 } from "uuid";
import "zx/globals";
import { autoNameCommand } from "./lib/ai/actions/auto-name-command";
import { copyLastMessageCommand } from "./lib/ai/actions/copy-command";
import { deleteCommand } from "./lib/ai/actions/delete-command";
import { dropLastMessageCommand } from "./lib/ai/actions/drop-last-command";
import { exitCommand } from "./lib/ai/actions/exit-command";
import { newConversationCommand } from "./lib/ai/actions/new-command";
import { pwdCommand } from "./lib/ai/actions/pwd-command";
import { RENAME_COMMAND, renameCommand } from "./lib/ai/actions/rename-command";
import { statusCommand } from "./lib/ai/actions/status-command";
import {
  WRITE_LAST_COMMAND,
  writeLastMessageCommand,
} from "./lib/ai/actions/write-last-command";
import { appendMessage } from "./lib/ai/append-message";
import { chooseConversation } from "./lib/ai/choose-conversation";
import { completeConversation } from "./lib/ai/complete-conversation";
import {
  ASSISTANT_PROMPT,
  META_FORMAT,
  USER_PROMPT,
  USER_PROMPT_2,
} from "./lib/ai/constants";
import { countWords } from "./lib/ai/count-words";
import { estimateReadingTime } from "./lib/ai/estimate-reading-time";
import { listConversations } from "./lib/ai/list-conversations";
import { listModels } from "./lib/ai/list-models";
import { Conversation } from "./lib/ai/llm-types";
import { parseChat } from "./lib/ai/parse-llm-chat";
import {
  selectInteractiveAction,
  selectModel,
  selectTerminalTitle,
} from "./lib/ai/selectors";
import { Store } from "./lib/ai/store";
import { SlashCommand, State } from "./lib/ai/types";
import { writeConversation } from "./lib/ai/write-conversation";
import { formatMarkdown } from "./lib/format-markdown";
import { hr } from "./lib/horizontal-rule";
import { setTerminalTitle } from "./lib/set-terminal-title";
import { withDefaultExtension } from "./lib/with-default-extension";

const HELP_COMMAND = "/help";
const EXIT_COMMAND = "/exit";
const NEW_COMMAND = "/new";
const DELETE_COMMAND = "/delete";
const COPY_COMMAND = "/copy";
const STATUS_COMMAND = "/status";
const AUTO_NAME_COMMAND = "/auto-name";
const DROP_LAST_COMMAND = "/drop-last";
const PWD_COMMAND = "/pwd";

const ROOT_DIR = argv._[0] ?? `${os.homedir()}/.ai`;

const store = new Store<State>({
  ROOT_DIR,
  CONVERSATION_BASENAME: uuid4(),
  model: argv.model ?? "gpt-4o",
  messages: [],
});

// Ensure the conversations directory exists
await $`mkdir -p ${ROOT_DIR}`;

// List sessions
if (argv.list) {
  await listConversations(ROOT_DIR);

  process.exit(0);
}

// List models and exit if given the --models flag
if (argv.models) {
  await listModels();

  process.exit(0);
}

if (argv.complete) {
  const conversationBasename = argv.complete;

  if (!conversationBasename) {
    console.log(
      META_FORMAT(`Usage: ${process.argv[1]} --complete <conversation>`)
    );
    process.exit(1);
  }

  const content = await fs.readFile(
    path.join(store.get("ROOT_DIR"), conversationBasename + ".md"),
    "utf8"
  );
  const { meta, messages } = await parseChat(content);

  const model = "model" in meta ? (meta.model as string) : "gpt-4o";

  const response = await completeConversation(model, messages);

  const completed: Conversation = [
    ...messages,
    {
      role: "assistant",
      content: response,
    },
  ];

  const wordCount = countWords(response);
  const estimatedReadingTime = estimateReadingTime(response);
  console.log(
    META_FORMAT(
      `\n\nEstimated reading time: ${estimatedReadingTime} minutes (${wordCount} words)`
    )
  );

  // Write the entire conversation to file
  const target = argv.target;
  if (target) {
    await writeConversation(store.get("ROOT_DIR"), target, completed, {
      model: store.get("model"),
    });
  }

  // Output only the last response to file
  const output = argv.output;
  if (output) {
    await fs.writeFile(withDefaultExtension(output, ".md"), response, "utf8");
  }

  process.exit(0);
}

// Delete a previous conversation
if (argv.delete) {
  const conversationBasename = await chooseConversation(ROOT_DIR);

  if (!conversationBasename) {
    process.exit(1);
  }

  await $`rm ${ROOT_DIR}/${conversationBasename}.md`;

  console.log(META_FORMAT(`Deleted conversation "${conversationBasename}"`));

  process.exit(0);
}

// Clear the console for interactive use
console.clear();

// Continue a previous conversation?
if (argv.continue || argv.resume) {
  // If the user provided a filename, continue from that file
  const basenameFromCommand = argv.continue ?? argv.resume;

  // Otherwise prompt the user to choose from conversations in the ROOT_DIR
  const conversationBasename =
    isString(basenameFromCommand) && !isEmpty(trim(basenameFromCommand))
      ? basenameFromCommand
      : await chooseConversation(ROOT_DIR);

  if (!conversationBasename) {
    process.exit(1);
  }

  console.log(META_FORMAT(`Continuing from "${conversationBasename}".`));

  store.set("CONVERSATION_BASENAME", argv.target ?? conversationBasename);

  const content = await fs.readFile(
    path.join(store.get("ROOT_DIR"), conversationBasename + ".md"),
    "utf8"
  );
  const { meta, messages: history } = await parseChat(content);

  if ("model" in meta) {
    store.set("model", meta.model as string);
  }

  store.set("messages", [...history]);

  const lastMessage = history[history.length - 1];

  if (lastMessage.role === "assistant") {
    // Display the last message of the conversation
    const lastMessageFormatted = await formatMarkdown(lastMessage.content);
    hr();
    console.log(ASSISTANT_PROMPT + lastMessageFormatted);
  } else {
    const state = store.getState();
    const response = await completeConversation(state.model, state.messages);

    await appendMessage(store, {
      role: "assistant",
      content: response,
    });

    console.log("\n");
  }
}

setTerminalTitle(selectTerminalTitle(store.getState()));

// Welcome message
hr();
const action = selectInteractiveAction(store);
console.log(
  META_FORMAT(
    `Chat with ${selectModel(
      store.getState()
    )} ${action}. Type '${EXIT_COMMAND}' to end the conversation. An empty line sends the current message buffer.`
  )
);
hr();

const SLASH_COMMANDS: Record<string, SlashCommand> = {
  [HELP_COMMAND]: {
    help: "Show this help message.",
    run: async (_input: string) => {
      console.log(chalk.grey("Available commands:"));

      for (const [command, { help }] of Object.entries(SLASH_COMMANDS)) {
        console.log(chalk.grey(`  ${command.padEnd(15)} ${help}`));
      }
    },
  },

  [NEW_COMMAND]: {
    help: "Start a new conversation.",
    run: async (_input: string) => {
      await store.execute(newConversationCommand);
    },
  },

  [STATUS_COMMAND]: {
    help: "Show the current conversation status.",
    run: async (_input: string) => {
      await store.execute(statusCommand);
    },
  },

  [EXIT_COMMAND]: {
    help: "End the conversation and quit.",
    run: async (_input: string) => {
      await store.execute(exitCommand);
    },
  },

  [COPY_COMMAND]: {
    help: "Copy the last message to the clipboard.",
    run: async (_input: string) => {
      await store.execute(copyLastMessageCommand);
    },
  },

  [RENAME_COMMAND]: {
    help: "Rename the current conversation.",
    run: async (input: string) => {
      const newName = input.slice(RENAME_COMMAND.length).trim();
      await store.execute(renameCommand, newName);
    },
  },

  [AUTO_NAME_COMMAND]: {
    help: "Generate a title for the conversation.",
    run: async (_input: string) => {
      await store.execute(autoNameCommand);
    },
  },

  [DELETE_COMMAND]: {
    help: "Delete the current conversation and start a new one.",
    run: async (_input: string) => {
      await store.execute(deleteCommand);
    },
  },

  [DROP_LAST_COMMAND]: {
    help: "Drop the last user/assistant message pair from the conversation.",
    run: async (_input: string) => {
      await store.execute(dropLastMessageCommand);
    },
  },

  [WRITE_LAST_COMMAND]: {
    help: "Write the last message to a file.",
    run: async (input: string) => {
      const filename = input.slice(WRITE_LAST_COMMAND.length).trim();
      await store.execute(writeLastMessageCommand, filename);
    },
  },

  [PWD_COMMAND]: {
    help: "Show the current working directory.",
    run: async (_input: string) => {
      await store.execute(pwdCommand);
    },
  },
};

let inputBuffer = "";

// Main chat loop
while (true) {
  if (inputBuffer.length === 0) {
    console.log("");
  }

  const input = await question(
    inputBuffer.length === 0 ? USER_PROMPT : USER_PROMPT_2
  );

  const [command] = input.toLowerCase().split(" ");
  if (command in SLASH_COMMANDS) {
    console.log("");
    hr();
    await SLASH_COMMANDS[command].run(input);
    hr();
    continue;
  }

  if (input.startsWith("/")) {
    console.log(META_FORMAT(`Unknown command: ${input}`));
    continue;
  }

  // Non-empty lines are appended to the current message
  if (input.length !== 0) {
    inputBuffer += input;
    setTerminalTitle("Press ENTER again to send the message.", { bell: true });
    continue;
  }

  setTerminalTitle(selectTerminalTitle(store.getState()));

  await appendMessage(store, { role: "user", content: inputBuffer });

  const { messages, model } = store.getState();
  const response = await completeConversation(model, messages);

  await appendMessage(store, {
    role: "assistant",
    content: response,
  });

  inputBuffer = "";

  hr();
}
